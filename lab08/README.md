# Отчет по лабораторной работе 8
# Жадные алгоритмы

**Дата:** 2025-12-06  
**Семестр:** 5  
**Группа:** ПИЖ-б-о-23-1  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Петрищев Ярослав Дмитриевич

## Цель работы
Изучить метод проектирования алгоритмов, известный как "жадный алгоритм". Освоить принцип принятия локально оптимальных решений на каждом шаге и понять условия, при которых этот подход приводит к глобально оптимальному решению. Получить практические навыки реализации жадных алгоритмов для решения классических задач, анализа их корректности и оценки эффективности.

## Теоретическая часть
*   **Жадный алгоритм:** Алгоритм, который на каждом шаге принимает **локально оптимальное решение** в надежде, что итоговое решение будет **глобально оптимальным**.
*   **Ключевые характеристики:**
    *   **Жадный выбор:** На каждом шаге выбирается лучший из доступных вариантов в данный момент, без учета последствий для будущих шагов.
    *   **Оптимальная подструктура:** Оптимальное решение задачи содержит в себе оптимальные решения её подзадач.
*   **Области применения:** Жадные алгоритмы эффективны для задач, где выбор, сделанный на каждом шаге, не ухудшает возможности достижения глобального оптимума. Они часто работают быстро (полиномиальное время), но **не всегда приводят к оптимальному решению**.
*   **Классические задачи:**
    *   **Задача о выборе заявок (Interval Scheduling):** Выбор максимального количества непересекающихся интервалов.
    *   **Задача о рюкзаке (Непрерывная/Дробная):** Выбор предметов с максимальной суммарной стоимостью, если можно брать части предметов.
    *   **Алгоритм Хаффмана:** Оптимальное префиксное кодирование для сжатия данных.
    *   **Построение минимального остовного дерева (Алгоритмы Прима и Краскала):** (Хотя это и графовый алгоритм, он является классическим примером жадного подхода).

## Практическая часть
### Выполненные задачи
1. Реализация классических жадных алгоритмов:
    - Задача о выборе заявок (Interval Scheduling)
    - Дробный рюкзак (Fractional Knapsack)
    - Алгоритм Хаффмана (Huffman Coding)
    - Задача о сдаче (Coin Change)
    - Алгоритм Краскала для минимального остовного дерева
2. Анализ корректности жадных алгоритмов: для каждого алгоритма объяснено, почему жадная стратегия приводит к оптимальному результату.
3. Сравнительный анализ эффективности жадного подхода и других методов: сравнение дробного рюкзака (жадный) и 0-1 рюкзака (точное решение) на небольших данных.
4. Экспериментальное исследование: замеры времени работы алгоритма Хаффмана на данных разного размера (от 100 до 10 000 символов).
5. Визуализация: построение дерева кодов Хаффмана и графика зависимости времени работы от размера входных данных.

### Ключевые фрагменты кода
**Интервальное планирование:**
```python
def interval_scheduling(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    """Выбирает максимальное количество непересекающихся интервалов."""
    sorted_intervals = sorted(intervals, key=lambda x: x[1])
    result = []
    last_end = -float('inf')
    for (start, end) in sorted_intervals:
        if start >= last_end:
            result.append((start, end))
            last_end = end
    return result
```

**Дробный рюкзак:**
```python
def fractional_knapsack(values: List[float], weights: List[float], capacity: float):
    items = [(v / w, i, v, w) for i, (v, w) in enumerate(zip(values, weights)) if w != 0]
    items.sort(key=lambda x: x[0], reverse=True)
    total_value = 0.0
    taken = []
    for ratio, i, v, w in items:
        if capacity <= 0:
            break
        take = min(1.0, capacity / w)
        total_value += v * take
        capacity -= w * take
        taken.append((i, take))
    return total_value, taken
```

**Алгоритм Хаффмана:**
```python
def build_huffman_tree(frequencies: Dict[str, int]) -> Optional[HuffNode]:
    heap = []
    counter = itertools.count()
    for sym, fr in frequencies.items():
        node = HuffNode(fr, sym)
        heap.append((fr, next(counter), node))
    heapq.heapify(heap)
    while len(heap) > 1:
        fr1, _, node1 = heapq.heappop(heap)
        fr2, _, node2 = heapq.heappop(heap)
        merged = HuffNode(fr1 + fr2, None, node1, node2)
        heapq.heappush(heap, (merged.freq, next(counter), merged))
    return heap[0][2]
```

## Результаты выполнения
### Пример работы программы
```bash
Примеры работы реализаций:

Interval Scheduling:
Вход: [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
Выбранные интервалы: [(1, 4), (5, 7), (8, 11), (12, 16)]

Fractional Knapsack:
Максимальное значение: 240.0
Взятое (index, fraction): [(0, 1.0), (1, 1.0), (2, 0.6666666666666666)]

Huffman codes:
a 0
c 100
b 101
f 1100
e 1101
d 111

Coin change (greedy) для значения = 63 с монетами [25,10,5,1]:
[2, 1, 0, 3]

Kruskal MST пример:
[(1, 2, 2.0), (0, 2, 3.0), (1, 3, 5.0)]

...

Fractional (greedy) значение: 240.0
0-1 точное (brute force) значение: 220.0
Fractional взятое: [(0, 1.0), (1, 1.0), (2, 0.66)]
0-1 выбор: [0, 1, 1]

Замеры Хаффмана:
n=   100 -> avg time 0.000000 sec
n=  1000 -> avg time 0.002278 sec
n=  5000 -> avg time 0.014618 sec
n= 10000 -> avg time 0.031667 sec

...


ПРИМЕР 1: Различные частоты {'a': 45, 'b': 13, 'c': 12, 'd': 16, 'e': 9, 'f': 5}
│           ┌── 'd':16
│       ┌── [30]
│       │   │   ┌── 'e':9
│       │   └── [14]
│       │       └── 'f':5
│   ┌── [55]
│   │   │   ┌── 'b':13
│   │   └── [25]
│   │       └── 'c':12
[100]
    └── 'a':45

------------------------------------------------------------
СООТВЕТСТВИЕ КОДОВ:
'a' → 0
'b' → 101
'c' → 100
'd' → 111
'e' → 1101
'f' → 1100
```

### Обоснование корректности жадного выбора для каждого алгоритма
1. **Интервальное планирование:** выбор интервала с минимальным временем окончания максимизирует количество непересекающихся интервалов, так как освобождает ресурс раньше.
2. **Дробный рюкзак:** сортировка по удельной стоимости гарантирует, что сначала берутся самые ценные предметы, что максимизирует суммарную стоимость.
3. **Алгоритм Хаффмана:** объединение узлов с наименьшими частотами минимизирует среднюю длину кода, что доказывается леммой о жадном выборе.
4. **Сдача монетами:** для стандартных систем монет жадный алгоритм дает минимальное количество монет, так как каждый шаг уменьшает оставшуюся сумму максимально возможным номиналом.
5. **Алгоритм Краскала:** выбор самого легкого ребра, не создающего цикла, гарантирует построение минимального остовного дерева.

### Анализ эффективности и ограничений жадных алгоритмов:
**Преимущества:** простота реализации, высокая скорость работы (полиномиальная сложность).  
**Недостатки:** не всегда гарантируют оптимальность (например, 0-1 рюкзак).  
**Применимость:** задачи с оптимальной подструктурой и свойством жадного выбора.  

### Сравнение эффективности жадных алгоритмов с наивными реализациями
#### Интервальное планирование
- **Жадный алгоритм:** 
    - Сложность: O(n log n) - сортировка интервалов по времени окончания  
    - Принцип: Выбирать интервал с наименьшим временем окончания, не пересекающийся с выбранными  
- **Наивная реализация (полный перебор):**
    - Сложность: O(2ⁿ × n²) — проверка всех подмножеств интервалов
    - Ограничение: Практически неприменимо при n > 20

#### Дробный рюкзак (Fractional Knapsack)
- **Жадный алгоритм:**
    - Сложность: O(n log n) - сортировка по удельной стоимости
    - Принцип: Брать предметы в порядке убывания стоимости за единицу веса

- **Наивная реализация:**
    - Сложность: O(kⁿ) — перебор всех комбинаций долей предметов
    - Ограничение: При k=100 и n=10 — 10¹⁰⁰ комбинаций (невычислимо)

#### Алгоритм Хаффмана
- **Жадный алгоритм:**
    - Сложность: O(n log n) - построение дерева с помощью кучи
    - Эффективность сжатия: На 25-40% лучше фиксированного кодирования

- **Наивная реализация:**
    - Сложность: Каталан(n) - перебор всех бинарных деревьев
    - Практичность: Неприменимо уже при n > 7

- **Альтернатива (фиксированное кодирование):**
    - Быстрее, но менее эффективно по сжатию
    - Не адаптируется к частотам символов

#### Задача о сдаче монетами
- **Жадный алгоритм:**
    - Сложность: O(n log n) - сортировка монет
    - Результат: всегда даёт минимальное количество монет

- **Наивная реализация (полный перебор):**
    - Сложность: Экспоненциальная от суммы
    - Преимущество: Находит оптимальное решение для любых систем монет.
    Пример (система [4,3,1], сумма 6): **жадный** - 3 монеты (4+1+1) - не оптимально, **наивный** - 2 монеты (3+3) - оптимально

## Выводы
1. Жадные алгоритмы эффективны для задач с оптимальной подструктурой и свойством жадного выбора, но не всегда гарантируют глобальный оптимум. Например, для дробного рюкзака жадный алгоритм оптимален, а для 0-1 рюкзака - нет.
2. Реализованные алгоритмы (интервальное планирование, дробный рюкзак, Хаффман, сдача монетами, Краскал) работают корректно и имеют ожидаемую временную сложность O(n log n).
3. Экспериментальные замеры подтвердили теоретическую оценку сложности алгоритма Хаффмана (O(n log n)). При увеличении объема данных в 100 раз время выполнения увеличилось примерно в 200 раз, что соответствует логарифмическому множителю.

## Ответы на контрольные вопросы
1. В чем заключается основная идея жадных алгоритмов?
    - Принимать локально оптимальное решение на каждом шаге в надежде получить глобально оптимальное решение.
2. Для задачи о выборе заявок (Interval Scheduling) жадный алгоритм, выбирающий интервалы с наименьшим временем окончания, является оптимальным. Объясните, почему эта жадная стратегия работает.
    - Выбор интервала, который раньше заканчивается, оставляет больше времени для последующих интервалов, что максимизирует общее количество выбранных интервалов.
3. Приведите пример задачи, для которой жадный алгоритм дает оптимальное решение, и задачи, для которой он не дает.
    - Оптимален: дробный рюкзак. Не оптимален: 0-1 рюкзак.
4. В чем разница между непрерывной (дробной) и дискретной (0-1) задачами о рюкзаке? Для какой из них жадный алгоритм оптимален?
    - В дробном рюкзаке можно брать части предметов, в 0-1 - только целиком. Жадный алгоритм оптимален для дробного рюкзака.
5. Опишите жадный алгоритм построения кода Хаффмана. В чем его оптимальность?
    - Алгоритм строит дерево, начиная с листьев (символов) и объединяя узлы с наименьшими частотами. Он оптимален, потому что обеспечивает минимальную среднюю длину кода.

## Приложения
### Характеристики ПК
- Процессор: Intel Core i5-7500 3.40GHz
- Оперативная память: 16GB
- Операционная система: Windows 11 24H2
- Python: 3.11.9

### Графики
**Алгоритм Хаффмана.**  
![Коды Хаффмана.](report/huffman_timings.png)